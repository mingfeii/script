#!/usr/bin/perl -w
use strict;
use Getopt::Long;

my $map_file = "map_file";
my $out_name = "io_ctrl_test.v";
my $author = "Peter.Shi";
my $result = "";
my $delay = "5";
my $chk_equal = ""; # the generated code used to check the equal relationship
my $debug = 0;
my $verbose = 0;
my $help = 0;
my $tab = " "x4;
my $equ_flag = "#";
my $sig_def = "";
my $DEBUG = "[DEBUG] --";
my $ERROR = "[ERROR] --";
my $VERBOSE = "[VERBOSE] --";

GetOptions(
           'map_file=s' => \$map_file,
           'out_name=s' => \$out_name,
           'author=s'   => \$author,
           'delay=s'    => \$delay,
           'help!'      => \$help,
           'verbose!'   => \$verbose,
           'debug!'     => \$debug,
          );

&help_msg() if $help;

&parse_and_gen_test_code($map_file, $out_name);

sub parse_and_gen_test_code {
    my ($file, $out_file) = @_;
    print "$DEBUG Start to parse the input map file $file and generate test code\n\n";
    my $sig_en = 0;           ## a signal that need to be tested occur
    my $com_en = 0; # the start commnet looks like "############...###" detected
    my $commit = "";
    my $drv_sig;
    my $chk_sig;
    my @equal_sigs; # the arrays that each of the signal must be equal to each other
    $sig_def .= "// The test case is generated by Perl script automatically and suggest you do not edit it by hand\n";
    $sig_def .= "// Author: $author\n";
    $result .= "\ninitial begin\n";
    open (IN, "<", $file) or die "${tab}Can not open $file for reading!\n";
    while (defined (my $line = <IN>)) {
        next if $line =~ /^\s*$/;
        next if $line =~ /^C.*$/; # "C xxx" is just a comment line and just skip it
        $line =~ s/^\s*|\s*$//g;
        if (($com_en && $sig_en) && $line =~ /^\s*#+\s*$/) { # detected the start comment for a signal that need to be tested 
            # finish one signal info and start another signal info
            # deal with the previous signal's force and check operation first
            &gen_test_code($drv_sig, $chk_sig, $commit, \@equal_sigs);
            @equal_sigs = ();
            $com_en = 1;
            $sig_en = 0;
        } elsif ((!$com_en && !$sig_en) && $line =~ /^\s*#+\s*$/) { 
            # detect the start section of the signal of the first time
            print "${tab}${VERBOSE} line = $line and Detect the start section of a signal\n\n" if $verbose;
            $com_en = 1;
            $sig_en = 0;
        } elsif ($com_en && !$sig_en && $line =~ /^\s*#+[\w\s]+/) {
            $sig_en = 1;
            $commit = $line;
        } elsif ($com_en && $sig_en && $line =~ /^\s*(.*)\s*\-\>\s*$/) {
            $drv_sig = $1;
        } elsif ($com_en && $sig_en && $line =~ /^\s*(.*)\s*\,\s*$/) {
            $chk_sig = $1;
        } elsif ($com_en && $sig_en && $line =~ /^\s*(.*)\s*${equ_flag}\s*$/) {
            my $cur_equ_sig = $1;
            push (@equal_sigs, $cur_equ_sig);
        } else {
            print "${tab}${ERROR} line = \"$line\" and detect error condtion from the map file $file. Exiting...\n\n";
            exit;
        }
    }
    close (IN);
    $result .= &gen_status(1, "OK");
    $result .= "${tab}\$finish;\n";
    $result .= "end\n\n";

    $result = $sig_def . $chk_equal . $result;

    open (OUT, ">", $out_file) or die "Can not open $out_file for writting!\n\n";
    print OUT $result;
    close (OUT);
    print "$DEBUG Complete to parse the input map file $file and generate test code\n\n";
    print "$DEBUG The generated test code according to mapping file $file has been written into $out_file\n\n";
}

sub gen_test_code {
    my ($src_sig, $chk_sig, $commit, $equ_ref) = @_;
    print "${tab}${DEBUG} Start generate test code for $src_sig \n\n";
    my $src_num;
    my $chk_num;
    $src_sig =~ s/^\s*|\s*$//g;
    $chk_sig =~ s/^\s*|\s*$//g;
    &obtain_bit_num($src_sig, \$src_num);
    &obtain_bit_num($chk_sig, \$chk_num);
    # $src_num = $chk_num if (!defined $src_num && $src_num !~ /^\d+$/ && defined $chk_num && $chk_num =~ /^\d+$/);
    my $msb = $src_num - 1;
    my $cur_sig_def = "sig\_${msb}\_0";
    if (!defined $sig_def || $sig_def !~ /sig\_${msb}\_0/) {
        $sig_def .= "reg [$msb:0] ${cur_sig_def};\n" 
    }
    # if ($src_num != $chk_num) {
    # print "${tab}${tab}${ERROR} the bit number between $src_sig and $chk_sig is different. Exiting...\n\n";
    # exit;
    # }

    $result .= "${tab}\/\/ $commit" . "\n";
    ## force signal and check result for $src_sig
    for (my $index = 0; $index < 3; $index = $index + 1) {
        my $tmp_val;
        my $cur_val = "";
        $tmp_val = "5" if ($index % 2 == 0);
        $tmp_val = "a" if ($index % 2 == 1);
        &gen_bit_val($src_num, \$cur_val, $tmp_val);
        $result .= "${tab}force $src_sig = ${cur_val};\n";
        $result .= "${tab}#${delay};\n";
        $result .= "${tab}${cur_sig_def} = ${chk_sig};\n";
        # $result .= "${tab}if ($chk_sig != ${cur_val}) begin\n";
        $result .= "${tab}if (${cur_sig_def} != ${cur_val}) begin\n";
        $result .= "${tab}${tab}\$display(\"[ERROR] force $src_sig to $cur_val but check fail\");\n";
        $result .= &gen_status(2, "FAIL");
        $result .= "${tab}${tab}\$finish;\n";
        $result .= "${tab}end\n";
        $result .= "${tab}else begin\n";
        $result .= "${tab}${tab}\$display(\"$DEBUG force $src_sig to $cur_val and check ok\");\n";
        $result .= "${tab}${tab}\$display();\n";
        $result .= "${tab}end\n";
        $result .= "\n";
    }
    $chk_equal .= &gen_chk_equal_code($src_sig, $equ_ref);

    print "${tab}${DEBUG} Complete generate test code for $src_sig \n\n";
}

sub gen_chk_equal_code {
    my ($src_sig, $equ_ref) = @_;
    print "${tab}${tab} Start to run gen_chk_equal_code \n\n" if $debug;
    my $str = "";
    my $cur_delay = int($delay / 2);
    return $str if (!defined $$equ_ref[0] || $$equ_ref[0] =~ /^\s*$/);

    $str .= "\n// check the equal relationship for $src_sig\n";
    $str .= "initial begin\n";
    $str .= "${tab}while(1) begin\n";
    # $str .= "${tab}${tab}// a delay or wait a clock signal\n";
    $str .= "${tab}${tab}#${cur_delay};\n";
    foreach my $equ_str (@$equ_ref) {
        $equ_str =~ s/\s+//g;
        $equ_str =~ s/\{|\}//g;
        $equ_str =~ s/${equ_flag}\s*$//;
        my @equ_arrs = split(/,/, $equ_str);
        my $num = 0;
        foreach my $item (@equ_arrs) { # check equ_arrs[0] equals with other items
            if ($equ_arrs[0] =~ /^${item}$/) { # the first item
                $str .= "${tab}${tab}if (";
                next;
            } elsif ($equ_arrs[$#equ_arrs] =~ /^${item}$/) { # the last item
                $str .= "$equ_arrs[0] != $item) begin\n" if (@equ_arrs == 2);
                $str .= "${tab}"x3 . "$equ_arrs[0] != $item) begin\n" if (@equ_arrs != 2);
                next;
            } else {
                $str .= "$equ_arrs[0] != $item || \n" if ($num == 0);
                $str .= "${tab}"x3 . "$equ_arrs[0] != $item || \n" if ($num > 0);
                $num++;
            }
        }
        my $item_sig;
        if ($equ_arrs[0] =~ /asic_io\.(.*)\s*$/) {
            $item_sig = $1;
        }
        $str .= "$tab"x3 . "\$display(\"$item_sig check fail\");\n";
        $str .= &gen_status(3, "FAIL");
        $str .= "${tab}"x3 . "\$finish;\n";
        $str .= "$tab"x2 . "end\n\n";
    }
    $str .= "${tab}end\n";
    $str .= "end\n";

    print "${tab}${tab} Complete to run gen_chk_equal_code \n\n" if $debug;
    return $str;
}

## a issue: bit_num = 21, $$val_ref = 21'h1FF_FFFF
sub gen_bit_val {
    my ($bit_num, $val_ref, $cur_val) = @_;
    print "${tab}${tab} Start to run gen_bit_val \n\n" if $debug;
    my $f_num = 0;
    my $num = int($bit_num / 4);
    # my $num = $bit_num / 4;
    my $left_num = $bit_num % 4;
    for (my $i = 0; $i < $num; $i = $i + 1) {
        $$val_ref = "$cur_val" . $$val_ref;
        $f_num++;
        $$val_ref = "_" . $$val_ref if ($f_num > 0 && ($f_num % 4 == 0) && ($i < ($num - 1)));
        $$val_ref = "_" . $$val_ref if ($f_num > 0 && ($f_num % 4 == 0) && ($i == ($num - 1)) && $left_num > 0);
    }

    if ($cur_val =~ /^a$/) {    # 1010
        # $$val_ref = "1" . $$val_ref if ($left_num == 1);
        $$val_ref = "2" . $$val_ref if ($left_num == 2);
        $$val_ref = "2" . $$val_ref if ($left_num == 3);
    } elsif ($cur_val =~ /^5$/) { # 0101
        $$val_ref = "1" . $$val_ref if ($left_num == 1);
        $$val_ref = "1" . $$val_ref if ($left_num == 2);
        $$val_ref = "5" . $$val_ref if ($left_num == 3);
    } else {
        print "${tab}${tab}${tab} gen_bit_val: cur_val = $cur_val but it is a invalid value! Exiting...\n\n";
        exit;
    }
    $$val_ref =~ s/^\_|\_$//;
    $$val_ref = "${bit_num}\'h" . $$val_ref;
    print "${tab}${tab} Complete to run gen_bit_val \n\n" if $debug;
}

sub obtain_bit_num {
    my ($text, $num_ref) = @_;
    if ($text =~ /\[(\d+)\:(\d+)\]$/) {
        my $num1 = $1;
        my $num2 = $2;
        $$num_ref = ($num1 - $num2 + 1) if ($num1 >= $num2);
        $$num_ref = ($num2 - $num1 + 1) if ($num1 < $num2);
    } else {
        $$num_ref = 1;
    }
}

sub gen_status {
    my ($tab_num, $test_status) = @_;
    my $str = "";
    $str .= "${tab}"x$tab_num . "\$display(\"# ----------------\");\n";
    $str .= "${tab}"x$tab_num . "\$display(\"# teststatus: ${test_status}\");\n";
    $str .= "${tab}"x$tab_num . "\$display(\"# ----------------\");\n";
    return $str;
}

sub help_msg {
    print "$0 is used to generate the io connect test case according to the mapping file\n\n";
    print "Usage: perl $0 \n";
    print "    or perl $0 -map_file map_file -out_name out_file_name [-author author_info] \n\n";

    print "A example for the map file:\n";
    print "-"x50 . "\n";
    print "${tab}##############################################################                      \n";
    print "${tab}# your commits for the current signals (will be displaed in the generated test case)\n";
    print "${tab}C your comment that will not exist in the generated test pattern                    \n";
    print "${tab}current core signals ->                                                             \n";
    print "${tab}{current asic_io pad signals},                                                      \n";
    print "${tab}{the current io pad signals that must be the same}#                                 \n";
    print "${tab}C ...                                                                               \n";
    print "${tab}{the current io pad signals that must be the same}#                                 \n";
    print "\n";
    print "${tab}##############################################################                      \n";
    print "${tab}# your commits for the another signals (will be displaed in the generated test case)\n";
    print "${tab}C your comment that will not exist in the generated test pattern                    \n";
    print "${tab}another core signals ->                                                             \n";
    print "${tab}{another asic_io pad signals},                                                      \n";
    print "${tab}{the another io pad signals that must be the same}#                                 \n";
    print "${tab}C ...                                                                               \n";
    print "${tab}{the another io pad signals that must be the same}#                                 \n";
    print "${tab}##############################################################                      \n";
    print "${tab}C the last \"###...###\" section is necessary to avoid skip the last signal's force and check operation\n";
    print "\n";

    print "Author: $author, 2014\n";
    exit;
}
